{"version":3,"sources":["../node_modules/@ionic/core/dist/esm-es5/ion-virtual-scroll.entry.js"],"names":["createNode","el","type","template","getTemplate","ownerDocument","importNode","content","children","querySelector","calcCells","items","itemHeight","headerHeight","footerHeight","headerFn","footerFn","approxHeaderHeight","approxFooterHeight","approxItemHeight","j","offset","len","cells","end","i","value","item","push","index","height","reads","visible","VirtualScroll","hostRef","_this","this","range","length","viewportHeight","virtualDom","isEnabled","viewportOffset","currentScrollTop","indexDirty","lastItemLen","totalHeight","onScroll","updateVirtualScroll","prototype","itemsChanged","componentDidLoad","contentEl","_a","_b","label","closest","componentOnReady","console","error","sent","getScrollElement","scrollEl","updateState","componentDidUpdate","componentDidUnload","undefined","onResize","positionForItem","Promise","resolve","heightIndex","cell","find","c","positionForIndex","getHeightIndex","checkRange","cellIndex","max","findIndex","findCellIndex","dst","src","inplaceUpdate","Math","scheduleUpdate","checkEnd","timerUpdate","clearTimeout","readVS","bind","writeVS","topOffset","node","offsetTop","parentElement","offsetHeight","scrollTop","dirtyIndex","viewport","vierportHeight","margin","top","bottom","getViewport","buffer","topPos","bottomPos","min","getRange","currentRange","getShouldUpdate","dom","_i","dom_1","change","d","toMutate","_loop_1","n","pool","filter","_loop_2","toMutate_1","forEach","updateVDom","nodeRender","updateCellHeight","child","Array","from","tagName","childrenNu","newChild","classList","add","appendChild","style","transform","remove","doRender","domRender","renderItem","forceUpdate","update","window","getComputedStyle","parseFloat","getPropertyValue","setCellHeight","then","setTimeout","shouldEnable","enableScrollEvents","Infinity","calcHeightIndex","buf","Uint32Array","newBuf","set","subarray","resizeBuffer","acum","shouldListen","rmEvent","addEventListener","removeEventListener","renderVirtualNode","renderHeader","renderFooter","render","VirtualProxy","map","Object","defineProperty","get","enumerable","configurable","utils","vattrs","classes","class","assign"],"mappings":"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","file":"static/js/91.8cc8d589.chunk.js","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { r as registerInstance, f as readTask, w as writeTask, h, H as Host, e as getElement } from './chunk-d0403a2f.js';\nimport './chunk-1074393c.js';\nvar CELL_TYPE_ITEM = 'item';\nvar CELL_TYPE_HEADER = 'header';\nvar CELL_TYPE_FOOTER = 'footer';\nvar NODE_CHANGE_NONE = 0;\nvar NODE_CHANGE_POSITION = 1;\nvar NODE_CHANGE_CELL = 2;\nvar MIN_READS = 2;\n\nvar updateVDom = function updateVDom(dom, heightIndex, cells, range) {\n  // reset dom\n  for (var _i = 0, dom_1 = dom; _i < dom_1.length; _i++) {\n    var node = dom_1[_i];\n    node.change = NODE_CHANGE_NONE;\n    node.d = true;\n  } // try to match into exisiting dom\n\n\n  var toMutate = [];\n  var end = range.offset + range.length;\n\n  var _loop_1 = function _loop_1(i) {\n    var cell = cells[i];\n    var node = dom.find(function (n) {\n      return n.d && n.cell === cell;\n    });\n\n    if (node) {\n      var top = heightIndex[i];\n\n      if (top !== node.top) {\n        node.top = top;\n        node.change = NODE_CHANGE_POSITION;\n      }\n\n      node.d = false;\n    } else {\n      toMutate.push(cell);\n    }\n  };\n\n  for (var i = range.offset; i < end; i++) {\n    _loop_1(i);\n  } // needs to append\n\n\n  var pool = dom.filter(function (n) {\n    return n.d;\n  });\n\n  var _loop_2 = function _loop_2(cell) {\n    var node = pool.find(function (n) {\n      return n.d && n.cell.type === cell.type;\n    });\n    var index = cell.i;\n\n    if (node) {\n      node.d = false;\n      node.change = NODE_CHANGE_CELL;\n      node.cell = cell;\n      node.top = heightIndex[index];\n    } else {\n      dom.push({\n        d: false,\n        cell: cell,\n        visible: true,\n        change: NODE_CHANGE_CELL,\n        top: heightIndex[index]\n      });\n    }\n  };\n\n  for (var _a = 0, toMutate_1 = toMutate; _a < toMutate_1.length; _a++) {\n    var cell = toMutate_1[_a];\n\n    _loop_2(cell);\n  }\n\n  dom.filter(function (n) {\n    return n.d && n.top !== -9999;\n  }).forEach(function (n) {\n    n.change = NODE_CHANGE_POSITION;\n    n.top = -9999;\n  });\n};\n\nvar doRender = function doRender(el, nodeRender, dom, updateCellHeight) {\n  var children = Array.from(el.children).filter(function (n) {\n    return n.tagName !== 'TEMPLATE';\n  });\n  var childrenNu = children.length;\n  var child;\n\n  for (var i = 0; i < dom.length; i++) {\n    var node = dom[i];\n    var cell = node.cell; // the cell change, the content must be updated\n\n    if (node.change === NODE_CHANGE_CELL) {\n      if (i < childrenNu) {\n        child = children[i];\n        nodeRender(child, cell, i);\n      } else {\n        var newChild = createNode(el, cell.type);\n        child = nodeRender(newChild, cell, i) || newChild;\n        child.classList.add('virtual-item');\n        el.appendChild(child);\n      }\n\n      child['$ionCell'] = cell;\n    } else {\n      child = children[i];\n    } // only update position when it changes\n\n\n    if (node.change !== NODE_CHANGE_NONE) {\n      child.style.transform = \"translate3d(0,\" + node.top + \"px,0)\";\n    } // update visibility\n\n\n    var visible = cell.visible;\n\n    if (node.visible !== visible) {\n      if (visible) {\n        child.classList.remove('virtual-loading');\n      } else {\n        child.classList.add('virtual-loading');\n      }\n\n      node.visible = visible;\n    } // dynamic height\n\n\n    if (cell.reads > 0) {\n      updateCellHeight(cell, child);\n      cell.reads--;\n    }\n  }\n};\n\nvar createNode = function createNode(el, type) {\n  var template = getTemplate(el, type);\n\n  if (template && el.ownerDocument) {\n    return el.ownerDocument.importNode(template.content, true).children[0];\n  }\n\n  return null;\n};\n\nvar getTemplate = function getTemplate(el, type) {\n  switch (type) {\n    case CELL_TYPE_ITEM:\n      return el.querySelector('template:not([name])');\n\n    case CELL_TYPE_HEADER:\n      return el.querySelector('template[name=header]');\n\n    case CELL_TYPE_FOOTER:\n      return el.querySelector('template[name=footer]');\n  }\n};\n\nvar getViewport = function getViewport(scrollTop, vierportHeight, margin) {\n  return {\n    top: Math.max(scrollTop - margin, 0),\n    bottom: scrollTop + vierportHeight + margin\n  };\n};\n\nvar getRange = function getRange(heightIndex, viewport, buffer) {\n  var topPos = viewport.top;\n  var bottomPos = viewport.bottom; // find top index\n\n  var i = 0;\n\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] > topPos) {\n      break;\n    }\n  }\n\n  var offset = Math.max(i - buffer - 1, 0); // find bottom index\n\n  for (; i < heightIndex.length; i++) {\n    if (heightIndex[i] >= bottomPos) {\n      break;\n    }\n  }\n\n  var end = Math.min(i + buffer, heightIndex.length);\n  var length = end - offset;\n  return {\n    offset: offset,\n    length: length\n  };\n};\n\nvar getShouldUpdate = function getShouldUpdate(dirtyIndex, currentRange, range) {\n  var end = range.offset + range.length;\n  return dirtyIndex <= end || currentRange.offset !== range.offset || currentRange.length !== range.length;\n};\n\nvar findCellIndex = function findCellIndex(cells, index) {\n  var max = cells.length > 0 ? cells[cells.length - 1].index : 0;\n\n  if (index === 0) {\n    return 0;\n  } else if (index === max + 1) {\n    return cells.length;\n  } else {\n    return cells.findIndex(function (c) {\n      return c.index === index;\n    });\n  }\n};\n\nvar inplaceUpdate = function inplaceUpdate(dst, src, offset) {\n  if (offset === 0 && src.length >= dst.length) {\n    return src;\n  }\n\n  for (var i = 0; i < src.length; i++) {\n    dst[i + offset] = src[i];\n  }\n\n  return dst;\n};\n\nvar calcCells = function calcCells(items, itemHeight, headerHeight, footerHeight, headerFn, footerFn, approxHeaderHeight, approxFooterHeight, approxItemHeight, j, offset, len) {\n  var cells = [];\n  var end = len + offset;\n\n  for (var i = offset; i < end; i++) {\n    var item = items[i];\n\n    if (headerFn) {\n      var value = headerFn(item, i, items);\n\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_HEADER,\n          value: value,\n          index: i,\n          height: headerHeight ? headerHeight(value, i) : approxHeaderHeight,\n          reads: headerHeight ? 0 : MIN_READS,\n          visible: !!headerHeight\n        });\n      }\n    }\n\n    cells.push({\n      i: j++,\n      type: CELL_TYPE_ITEM,\n      value: item,\n      index: i,\n      height: itemHeight ? itemHeight(item, i) : approxItemHeight,\n      reads: itemHeight ? 0 : MIN_READS,\n      visible: !!itemHeight\n    });\n\n    if (footerFn) {\n      var value = footerFn(item, i, items);\n\n      if (value != null) {\n        cells.push({\n          i: j++,\n          type: CELL_TYPE_FOOTER,\n          value: value,\n          index: i,\n          height: footerHeight ? footerHeight(value, i) : approxFooterHeight,\n          reads: footerHeight ? 0 : MIN_READS,\n          visible: !!footerHeight\n        });\n      }\n    }\n  }\n\n  return cells;\n};\n\nvar calcHeightIndex = function calcHeightIndex(buf, cells, index) {\n  var acum = buf[index];\n\n  for (var i = index; i < buf.length; i++) {\n    buf[i] = acum;\n    acum += cells[i].height;\n  }\n\n  return acum;\n};\n\nvar resizeBuffer = function resizeBuffer(buf, len) {\n  if (!buf) {\n    return new Uint32Array(len);\n  }\n\n  if (buf.length === len) {\n    return buf;\n  } else if (len > buf.length) {\n    var newBuf = new Uint32Array(len);\n    newBuf.set(buf);\n    return newBuf;\n  } else {\n    return buf.subarray(0, len);\n  }\n};\n\nvar positionForIndex = function positionForIndex(index, cells, heightIndex) {\n  var cell = cells.find(function (c) {\n    return c.type === CELL_TYPE_ITEM && c.index === index;\n  });\n\n  if (cell) {\n    return heightIndex[cell.i];\n  }\n\n  return -1;\n};\n\nvar VirtualScroll =\n/** @class */\nfunction () {\n  function VirtualScroll(hostRef) {\n    var _this = this;\n\n    registerInstance(this, hostRef);\n    this.range = {\n      offset: 0,\n      length: 0\n    };\n    this.viewportHeight = 0;\n    this.cells = [];\n    this.virtualDom = [];\n    this.isEnabled = false;\n    this.viewportOffset = 0;\n    this.currentScrollTop = 0;\n    this.indexDirty = 0;\n    this.lastItemLen = 0;\n    this.totalHeight = 0;\n    /**\n     * It is important to provide this\n     * if virtual item height will be significantly larger than the default\n     * The approximate height of each virtual item template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxItemHeight = 45;\n    /**\n     * The approximate height of each header template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxHeaderHeight = 30;\n    /**\n     * The approximate width of each footer template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered.\n     */\n\n    this.approxFooterHeight = 30;\n\n    this.onScroll = function () {\n      _this.updateVirtualScroll();\n    };\n  }\n\n  VirtualScroll.prototype.itemsChanged = function () {\n    this.calcCells();\n    this.updateVirtualScroll();\n  };\n\n  VirtualScroll.prototype.componentDidLoad = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var contentEl, _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            contentEl = this.el.closest('ion-content');\n\n            if (!contentEl) {\n              console.error('virtual-scroll must be used inside ion-content');\n              return [2\n              /*return*/\n              ];\n            }\n\n            return [4\n            /*yield*/\n            , contentEl.componentOnReady()];\n\n          case 1:\n            _b.sent();\n\n            this.contentEl = contentEl;\n            _a = this;\n            return [4\n            /*yield*/\n            , contentEl.getScrollElement()];\n\n          case 2:\n            _a.scrollEl = _b.sent();\n            this.calcCells();\n            this.updateState();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  VirtualScroll.prototype.componentDidUpdate = function () {\n    this.updateState();\n  };\n\n  VirtualScroll.prototype.componentDidUnload = function () {\n    this.scrollEl = undefined;\n  };\n\n  VirtualScroll.prototype.onResize = function () {\n    this.calcCells();\n    this.updateVirtualScroll();\n  };\n  /**\n   * Returns the position of the virtual item at the given index.\n   */\n\n\n  VirtualScroll.prototype.positionForItem = function (index) {\n    return Promise.resolve(positionForIndex(index, this.cells, this.getHeightIndex()));\n  };\n  /**\n   * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as\n   * dirty any time the content or their style changes.\n   *\n   * The subset of items to be updated can are specifing by an offset and a length.\n   */\n\n\n  VirtualScroll.prototype.checkRange = function (offset, len) {\n    if (len === void 0) {\n      len = -1;\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var length, cellIndex, cells;\n      return tslib_1.__generator(this, function (_a) {\n        // TODO: kind of hacky how we do in-place updated of the cells\n        // array. this part needs a complete refactor\n        if (!this.items) {\n          return [2\n          /*return*/\n          ];\n        }\n\n        length = len === -1 ? this.items.length - offset : len;\n        cellIndex = findCellIndex(this.cells, offset);\n        cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, cellIndex, offset, length);\n        this.cells = inplaceUpdate(this.cells, cells, cellIndex);\n        this.lastItemLen = this.items.length;\n        this.indexDirty = Math.max(offset - 1, 0);\n        this.scheduleUpdate();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * This method marks the tail the items array as dirty, so they can be re-rendered.\n   *\n   * It's equivalent to calling:\n   *\n   * ```js\n   * virtualScroll.checkRange(lastItemLen);\n   * ```\n   */\n\n\n  VirtualScroll.prototype.checkEnd = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        if (this.items) {\n          this.checkRange(this.lastItemLen);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  VirtualScroll.prototype.updateVirtualScroll = function () {\n    // do nothing if virtual-scroll is disabled\n    if (!this.isEnabled || !this.scrollEl) {\n      return;\n    } // unschedule future updates\n\n\n    if (this.timerUpdate) {\n      clearTimeout(this.timerUpdate);\n      this.timerUpdate = undefined;\n    } // schedule DOM operations into the stencil queue\n\n\n    readTask(this.readVS.bind(this));\n    writeTask(this.writeVS.bind(this));\n  };\n\n  VirtualScroll.prototype.readVS = function () {\n    var _a = this,\n        contentEl = _a.contentEl,\n        scrollEl = _a.scrollEl,\n        el = _a.el;\n\n    var topOffset = 0;\n    var node = el;\n\n    while (node && node !== contentEl) {\n      topOffset += node.offsetTop;\n      node = node.parentElement;\n    }\n\n    this.viewportOffset = topOffset;\n\n    if (scrollEl) {\n      this.viewportHeight = scrollEl.offsetHeight;\n      this.currentScrollTop = scrollEl.scrollTop;\n    }\n  };\n\n  VirtualScroll.prototype.writeVS = function () {\n    var dirtyIndex = this.indexDirty; // get visible viewport\n\n    var scrollTop = this.currentScrollTop - this.viewportOffset;\n    var viewport = getViewport(scrollTop, this.viewportHeight, 100); // compute lazily the height index\n\n    var heightIndex = this.getHeightIndex(); // get array bounds of visible cells base in the viewport\n\n    var range = getRange(heightIndex, viewport, 2); // fast path, do nothing\n\n    var shouldUpdate = getShouldUpdate(dirtyIndex, this.range, range);\n\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.range = range; // in place mutation of the virtual DOM\n\n    updateVDom(this.virtualDom, heightIndex, this.cells, range); // Write DOM\n    // Different code paths taken depending of the render API used\n\n    if (this.nodeRender) {\n      doRender(this.el, this.nodeRender, this.virtualDom, this.updateCellHeight.bind(this));\n    } else if (this.domRender) {\n      this.domRender(this.virtualDom);\n    } else if (this.renderItem) {\n      this.el.forceUpdate();\n    }\n  };\n\n  VirtualScroll.prototype.updateCellHeight = function (cell, node) {\n    var _this = this;\n\n    var update = function update() {\n      if (node['$ionCell'] === cell) {\n        var style = window.getComputedStyle(node);\n        var height = node.offsetHeight + parseFloat(style.getPropertyValue('margin-bottom'));\n\n        _this.setCellHeight(cell, height);\n      }\n    };\n\n    if (node && node.componentOnReady) {\n      node.componentOnReady().then(update);\n    } else {\n      update();\n    }\n  };\n\n  VirtualScroll.prototype.setCellHeight = function (cell, height) {\n    var index = cell.i; // the cell might changed since the height update was scheduled\n\n    if (cell !== this.cells[index]) {\n      return;\n    }\n\n    if (cell.height !== height || cell.visible !== true) {\n      cell.visible = true;\n      cell.height = height;\n      this.indexDirty = Math.min(this.indexDirty, index);\n      this.scheduleUpdate();\n    }\n  };\n\n  VirtualScroll.prototype.scheduleUpdate = function () {\n    var _this = this;\n\n    clearTimeout(this.timerUpdate);\n    this.timerUpdate = setTimeout(function () {\n      return _this.updateVirtualScroll();\n    }, 100);\n  };\n\n  VirtualScroll.prototype.updateState = function () {\n    var shouldEnable = !!(this.scrollEl && this.cells);\n\n    if (shouldEnable !== this.isEnabled) {\n      this.enableScrollEvents(shouldEnable);\n\n      if (shouldEnable) {\n        this.updateVirtualScroll();\n      }\n    }\n  };\n\n  VirtualScroll.prototype.calcCells = function () {\n    if (!this.items) {\n      return;\n    }\n\n    this.lastItemLen = this.items.length;\n    this.cells = calcCells(this.items, this.itemHeight, this.headerHeight, this.footerHeight, this.headerFn, this.footerFn, this.approxHeaderHeight, this.approxFooterHeight, this.approxItemHeight, 0, 0, this.lastItemLen);\n    this.indexDirty = 0;\n  };\n\n  VirtualScroll.prototype.getHeightIndex = function () {\n    if (this.indexDirty !== Infinity) {\n      this.calcHeightIndex(this.indexDirty);\n    }\n\n    return this.heightIndex;\n  };\n\n  VirtualScroll.prototype.calcHeightIndex = function (index) {\n    if (index === void 0) {\n      index = 0;\n    } // TODO: optimize, we don't need to calculate all the cells\n\n\n    this.heightIndex = resizeBuffer(this.heightIndex, this.cells.length);\n    this.totalHeight = calcHeightIndex(this.heightIndex, this.cells, index);\n    this.indexDirty = Infinity;\n  };\n\n  VirtualScroll.prototype.enableScrollEvents = function (shouldListen) {\n    var _this = this;\n\n    if (this.rmEvent) {\n      this.rmEvent();\n      this.rmEvent = undefined;\n    }\n\n    var scrollEl = this.scrollEl;\n\n    if (scrollEl) {\n      this.isEnabled = shouldListen;\n      scrollEl.addEventListener('scroll', this.onScroll);\n\n      this.rmEvent = function () {\n        scrollEl.removeEventListener('scroll', _this.onScroll);\n      };\n    }\n  };\n\n  VirtualScroll.prototype.renderVirtualNode = function (node) {\n    var _a = node.cell,\n        type = _a.type,\n        value = _a.value,\n        index = _a.index;\n\n    switch (type) {\n      case CELL_TYPE_ITEM:\n        return this.renderItem(value, index);\n\n      case CELL_TYPE_HEADER:\n        return this.renderHeader(value, index);\n\n      case CELL_TYPE_FOOTER:\n        return this.renderFooter(value, index);\n    }\n  };\n\n  VirtualScroll.prototype.render = function () {\n    var _this = this;\n\n    return h(Host, {\n      style: {\n        height: this.totalHeight + \"px\"\n      }\n    }, this.renderItem && h(VirtualProxy, {\n      dom: this.virtualDom\n    }, this.virtualDom.map(function (node) {\n      return _this.renderVirtualNode(node);\n    })));\n  };\n\n  Object.defineProperty(VirtualScroll.prototype, \"el\", {\n    get: function get() {\n      return getElement(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(VirtualScroll, \"watchers\", {\n    get: function get() {\n      return {\n        \"itemHeight\": [\"itemsChanged\"],\n        \"headerHeight\": [\"itemsChanged\"],\n        \"footerHeight\": [\"itemsChanged\"],\n        \"items\": [\"itemsChanged\"]\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(VirtualScroll, \"style\", {\n    get: function get() {\n      return \"ion-virtual-scroll{display:block;position:relative;width:100%;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-virtual-scroll>.virtual-loading{opacity:0}ion-virtual-scroll>.virtual-item{position:absolute!important;top:0!important;right:0!important;left:0!important;-webkit-transition-duration:0ms;transition-duration:0ms;will-change:transform}\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return VirtualScroll;\n}();\n\nvar VirtualProxy = function VirtualProxy(_a, children, utils) {\n  var dom = _a.dom;\n  return utils.map(children, function (child, i) {\n    var node = dom[i];\n    var vattrs = child.vattrs || {};\n    var classes = vattrs.class || '';\n    classes += 'virtual-item ';\n\n    if (!node.visible) {\n      classes += 'virtual-loading';\n    }\n\n    return Object.assign({}, child, {\n      vattrs: Object.assign({}, vattrs, {\n        class: classes,\n        style: Object.assign({}, vattrs.style, {\n          transform: \"translate3d(0,\" + node.top + \"px,0)\"\n        })\n      })\n    });\n  });\n};\n\nexport { VirtualScroll as ion_virtual_scroll };"],"sourceRoot":""}